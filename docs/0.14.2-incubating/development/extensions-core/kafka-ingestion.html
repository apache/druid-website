<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Apache Druid">
<meta name="keywords" content="druid,kafka,database,analytics,streaming,real-time,real time,apache,open source">
<meta name="author" content="Apache Software Foundation">

<title>Druid | Apache Kafka Indexing Service</title>

<link rel="alternate" type="application/atom+xml" href="/feed">
<link rel="shortcut icon" href="/img/favicon.png">

<link rel="stylesheet" href="/assets/css/font-awesome-5.css">

<link href='//fonts.googleapis.com/css?family=Open+Sans+Condensed:300,700,300italic|Open+Sans:300italic,400italic,600italic,400,300,600,700' rel='stylesheet' type='text/css'>

<link rel="stylesheet" href="/css/bootstrap-pure.css?v=1.1">
<link rel="stylesheet" href="/css/base.css?v=1.1">
<link rel="stylesheet" href="/css/header.css?v=1.1">
<link rel="stylesheet" href="/css/footer.css?v=1.1">
<link rel="stylesheet" href="/css/syntax.css?v=1.1">
<link rel="stylesheet" href="/css/docs.css?v=1.1">

<script>
  (function() {
    var cx = '000162378814775985090:molvbm0vggm';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>


  </head>

  <body>
    <!-- Start page_header include -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>

<div class="top-navigator">
  <div class="container">
    <div class="left-cont">
      <a class="logo" href="/"><span class="druid-logo"></span></a>
    </div>
    <div class="right-cont">
      <ul class="links">
        <li class=""><a href="/technology">Technology</a></li>
        <li class=""><a href="/use-cases">Use Cases</a></li>
        <li class=""><a href="/druid-powered">Powered By</a></li>
        <li class=""><a href="/docs/latest/design/">Docs</a></li>
        <li class=""><a href="/community/">Community</a></li>
        <li class="header-dropdown">
          <a>Apache</a>
          <div class="header-dropdown-menu">
            <a href="https://www.apache.org/" target="_blank">Foundation</a>
            <a href="https://www.apache.org/events/current-event" target="_blank">Events</a>
            <a href="https://www.apache.org/licenses/" target="_blank">License</a>
            <a href="https://www.apache.org/foundation/thanks.html" target="_blank">Thanks</a>
            <a href="https://www.apache.org/security/" target="_blank">Security</a>
            <a href="https://www.apache.org/foundation/sponsorship.html" target="_blank">Sponsorship</a>
          </div>
        </li>
        <li class=" button-link"><a href="/downloads.html">Download</a></li>
      </ul>
    </div>
  </div>
  <div class="action-button menu-icon">
    <span class="fa fa-bars"></span> MENU
  </div>
  <div class="action-button menu-icon-close">
    <span class="fa fa-times"></span> MENU
  </div>
</div>

<script type="text/javascript">
  var $menu = $('.right-cont');
  var $menuIcon = $('.menu-icon');
  var $menuIconClose = $('.menu-icon-close');

  function showMenu() {
    $menu.fadeIn(100);
    $menuIcon.fadeOut(100);
    $menuIconClose.fadeIn(100);
  }

  $menuIcon.click(showMenu);

  function hideMenu() {
    $menu.fadeOut(100);
    $menuIconClose.fadeOut(100);
    $menuIcon.fadeIn(100);
  }

  $menuIconClose.click(hideMenu);

  $(window).resize(function() {
    if ($(window).width() >= 840) {
      $menu.fadeIn(100);
      $menuIcon.fadeOut(100);
      $menuIconClose.fadeOut(100);
    }
    else {
      $menu.fadeOut(100);
      $menuIcon.fadeIn(100);
      $menuIconClose.fadeOut(100);
    }
  });
</script>

<!-- Stop page_header include -->


    <div class="container doc-container">
      
      

      
      <p> Looking for the <a href="/docs/24.0.1/">latest stable documentation</a>?</p>
      

      <div class="row">
        <div class="col-md-9 doc-content">
          <p>
            <a class="btn btn-default btn-xs visible-xs-inline-block visible-sm-inline-block" href="#toc">Table of Contents</a>
          </p>
          <!--
  ~ Licensed to the Apache Software Foundation (ASF) under one
  ~ or more contributor license agreements.  See the NOTICE file
  ~ distributed with this work for additional information
  ~ regarding copyright ownership.  The ASF licenses this file
  ~ to you under the Apache License, Version 2.0 (the
  ~ "License"); you may not use this file except in compliance
  ~ with the License.  You may obtain a copy of the License at
  ~
  ~   http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing,
  ~ software distributed under the License is distributed on an
  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  ~ KIND, either express or implied.  See the License for the
  ~ specific language governing permissions and limitations
  ~ under the License.
  -->

<h1 id="kafka-indexing-service">Kafka Indexing Service</h1>

<p>The Kafka indexing service enables the configuration of <em>supervisors</em> on the Overlord, which facilitate ingestion from
Kafka by managing the creation and lifetime of Kafka indexing tasks. These indexing tasks read events using Kafka&#39;s own
partition and offset mechanism and are therefore able to provide guarantees of exactly-once ingestion. They are also
able to read non-recent events from Kafka and are not subject to the window period considerations imposed on other
ingestion mechanisms using Tranquility. The supervisor oversees the state of the indexing tasks to coordinate handoffs, manage failures,
and ensure that the scalability and replication requirements are maintained.</p>

<p>This service is provided in the <code>druid-kafka-indexing-service</code> core Apache Druid (incubating) extension (see
<a href="../../operations/including-extensions.html">Including Extensions</a>).</p>

<div class="note info">
The Kafka indexing service uses the Java consumer that was introduced in Kafka 0.10.x. As there were protocol changes
made in this version, Kafka 0.10.x consumers might not be compatible with older brokers. Ensure that your Kafka brokers are
version 0.10.x or better before using this functionality. Refer <a href="https://kafka.apache.org/documentation/#upgrade">Kafka upgrade guide</a> if you are using older version of Kafka brokers.
</div>

<h2 id="submitting-a-supervisor-spec">Submitting a Supervisor Spec</h2>

<p>The Kafka indexing service requires that the <code>druid-kafka-indexing-service</code> extension be loaded on both the Overlord and the
MiddleManagers. A supervisor for a dataSource is started by submitting a supervisor spec via HTTP POST to
<code>http://&lt;OVERLORD_IP&gt;:&lt;OVERLORD_PORT&gt;/druid/indexer/v1/supervisor</code>, for example:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>curl -X POST -H &#39;Content-Type: application/json&#39; -d @supervisor-spec.json http://localhost:8090/druid/indexer/v1/supervisor
</code></pre></div>
<p>A sample supervisor spec is shown below:</p>
<div class="highlight"><pre><code class="language-json" data-lang="json"><span></span><span class="p">{</span>
  <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;kafka&quot;</span><span class="p">,</span>
  <span class="nt">&quot;dataSchema&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;dataSource&quot;</span><span class="p">:</span> <span class="s2">&quot;metrics-kafka&quot;</span><span class="p">,</span>
    <span class="nt">&quot;parser&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
      <span class="nt">&quot;parseSpec&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;json&quot;</span><span class="p">,</span>
        <span class="nt">&quot;timestampSpec&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&quot;column&quot;</span><span class="p">:</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
          <span class="nt">&quot;format&quot;</span><span class="p">:</span> <span class="s2">&quot;auto&quot;</span>
        <span class="p">},</span>
        <span class="nt">&quot;dimensionsSpec&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&quot;dimensions&quot;</span><span class="p">:</span> <span class="p">[],</span>
          <span class="nt">&quot;dimensionExclusions&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nt">&quot;metricsSpec&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;value_sum&quot;</span><span class="p">,</span>
        <span class="nt">&quot;fieldName&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;doubleSum&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;value_min&quot;</span><span class="p">,</span>
        <span class="nt">&quot;fieldName&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;doubleMin&quot;</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;value_max&quot;</span><span class="p">,</span>
        <span class="nt">&quot;fieldName&quot;</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;doubleMax&quot;</span>
      <span class="p">}</span>
    <span class="p">],</span>
    <span class="nt">&quot;granularitySpec&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;uniform&quot;</span><span class="p">,</span>
      <span class="nt">&quot;segmentGranularity&quot;</span><span class="p">:</span> <span class="s2">&quot;HOUR&quot;</span><span class="p">,</span>
      <span class="nt">&quot;queryGranularity&quot;</span><span class="p">:</span> <span class="s2">&quot;NONE&quot;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nt">&quot;tuningConfig&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;kafka&quot;</span><span class="p">,</span>
    <span class="nt">&quot;maxRowsPerSegment&quot;</span><span class="p">:</span> <span class="mi">5000000</span>
  <span class="p">},</span>
  <span class="nt">&quot;ioConfig&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;topic&quot;</span><span class="p">:</span> <span class="s2">&quot;metrics&quot;</span><span class="p">,</span>
    <span class="nt">&quot;consumerProperties&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;bootstrap.servers&quot;</span><span class="p">:</span> <span class="s2">&quot;localhost:9092&quot;</span>
    <span class="p">},</span>
    <span class="nt">&quot;taskCount&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&quot;replicas&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&quot;taskDuration&quot;</span><span class="p">:</span> <span class="s2">&quot;PT1H&quot;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="supervisor-configuration">Supervisor Configuration</h2>

<table><thead>
<tr>
<th>Field</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>type</code></td>
<td>The supervisor type, this should always be <code>kafka</code>.</td>
<td>yes</td>
</tr>
<tr>
<td><code>dataSchema</code></td>
<td>The schema that will be used by the Kafka indexing task during ingestion, see <a href="../../ingestion/ingestion-spec.html#dataschema">Ingestion Spec DataSchema</a>.</td>
<td>yes</td>
</tr>
<tr>
<td><code>ioConfig</code></td>
<td>A KafkaSupervisorIOConfig to configure the supervisor and indexing tasks, see below.</td>
<td>yes</td>
</tr>
<tr>
<td><code>tuningConfig</code></td>
<td>A KafkaSupervisorTuningConfig to configure the supervisor and indexing tasks, see below.</td>
<td>no</td>
</tr>
</tbody></table>

<h3 id="kafkasupervisortuningconfig">KafkaSupervisorTuningConfig</h3>

<p>The tuningConfig is optional and default parameters will be used if no tuningConfig is specified.</p>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>type</code></td>
<td>String</td>
<td>The indexing task type, this should always be <code>kafka</code>.</td>
<td>yes</td>
</tr>
<tr>
<td><code>maxRowsInMemory</code></td>
<td>Integer</td>
<td>The number of rows to aggregate before persisting. This number is the post-aggregation rows, so it is not equivalent to the number of input events, but the number of aggregated rows that those events result in. This is used to manage the required JVM heap size. Maximum heap memory usage for indexing scales with maxRowsInMemory * (2 + maxPendingPersists). Normally user does not need to set this, but depending on the nature of data, if rows are short in terms of bytes, user may not want to store a million rows in memory and this value should be set.</td>
<td>no (default == 1000000)</td>
</tr>
<tr>
<td><code>maxBytesInMemory</code></td>
<td>Long</td>
<td>The number of bytes to aggregate in heap memory before persisting. This is based on a rough estimate of memory usage and not actual usage. Normally this is computed internally and user does not need to set it. The maximum heap memory usage for indexing is maxBytesInMemory * (2 + maxPendingPersists).</td>
<td>no (default == One-sixth of max JVM memory)</td>
</tr>
<tr>
<td><code>maxRowsPerSegment</code></td>
<td>Integer</td>
<td>The number of rows to aggregate into a segment; this number is post-aggregation rows. Handoff will happen either if <code>maxRowsPerSegment</code> or <code>maxTotalRows</code> is hit or every <code>intermediateHandoffPeriod</code>, whichever happens earlier.</td>
<td>no (default == 5000000)</td>
</tr>
<tr>
<td><code>maxTotalRows</code></td>
<td>Long</td>
<td>The number of rows to aggregate across all segments; this number is post-aggregation rows. Handoff will happen either if <code>maxRowsPerSegment</code> or <code>maxTotalRows</code> is hit or every <code>intermediateHandoffPeriod</code>, whichever happens earlier.</td>
<td>no (default == unlimited)</td>
</tr>
<tr>
<td><code>intermediatePersistPeriod</code></td>
<td>ISO8601 Period</td>
<td>The period that determines the rate at which intermediate persists occur.</td>
<td>no (default == PT10M)</td>
</tr>
<tr>
<td><code>maxPendingPersists</code></td>
<td>Integer</td>
<td>Maximum number of persists that can be pending but not started. If this limit would be exceeded by a new intermediate persist, ingestion will block until the currently-running persist finishes. Maximum heap memory usage for indexing scales with maxRowsInMemory * (2 + maxPendingPersists).</td>
<td>no (default == 0, meaning one persist can be running concurrently with ingestion, and none can be queued up)</td>
</tr>
<tr>
<td><code>indexSpec</code></td>
<td>Object</td>
<td>Tune how data is indexed, see &#39;IndexSpec&#39; below for more details.</td>
<td>no</td>
</tr>
<tr>
<td><code>reportParseExceptions</code></td>
<td>Boolean</td>
<td><em>DEPRECATED</em>. If true, exceptions encountered during parsing will be thrown and will halt ingestion; if false, unparseable rows and fields will be skipped. Setting <code>reportParseExceptions</code> to true will override existing configurations for <code>maxParseExceptions</code> and <code>maxSavedParseExceptions</code>, setting <code>maxParseExceptions</code> to 0 and limiting <code>maxSavedParseExceptions</code> to no more than 1.</td>
<td>no (default == false)</td>
</tr>
<tr>
<td><code>handoffConditionTimeout</code></td>
<td>Long</td>
<td>Milliseconds to wait for segment handoff. It must be &gt;= 0, where 0 means to wait forever.</td>
<td>no (default == 0)</td>
</tr>
<tr>
<td><code>resetOffsetAutomatically</code></td>
<td>Boolean</td>
<td>Whether to reset the consumer offset if the next offset that it is trying to fetch is less than the earliest available offset for that particular partition. The consumer offset will be reset to either the earliest or latest offset depending on <code>useEarliestOffset</code> property of <code>KafkaSupervisorIOConfig</code> (see below). This situation typically occurs when messages in Kafka are no longer available for consumption and therefore won&#39;t be ingested into Druid. If set to false then ingestion for that particular partition will halt and manual intervention is required to correct the situation, please see <code>Reset Supervisor</code> API below.</td>
<td>no (default == false)</td>
</tr>
<tr>
<td><code>workerThreads</code></td>
<td>Integer</td>
<td>The number of threads that will be used by the supervisor for asynchronous operations.</td>
<td>no (default == min(10, taskCount))</td>
</tr>
<tr>
<td><code>chatThreads</code></td>
<td>Integer</td>
<td>The number of threads that will be used for communicating with indexing tasks.</td>
<td>no (default == min(10, taskCount * replicas))</td>
</tr>
<tr>
<td><code>chatRetries</code></td>
<td>Integer</td>
<td>The number of times HTTP requests to indexing tasks will be retried before considering tasks unresponsive.</td>
<td>no (default == 8)</td>
</tr>
<tr>
<td><code>httpTimeout</code></td>
<td>ISO8601 Period</td>
<td>How long to wait for a HTTP response from an indexing task.</td>
<td>no (default == PT10S)</td>
</tr>
<tr>
<td><code>shutdownTimeout</code></td>
<td>ISO8601 Period</td>
<td>How long to wait for the supervisor to attempt a graceful shutdown of tasks before exiting.</td>
<td>no (default == PT80S)</td>
</tr>
<tr>
<td><code>offsetFetchPeriod</code></td>
<td>ISO8601 Period</td>
<td>How often the supervisor queries Kafka and the indexing tasks to fetch current offsets and calculate lag.</td>
<td>no (default == PT30S, min == PT5S)</td>
</tr>
<tr>
<td><code>segmentWriteOutMediumFactory</code></td>
<td>Object</td>
<td>Segment write-out medium to use when creating segments. See below for more information.</td>
<td>no (not specified by default, the value from <code>druid.peon.defaultSegmentWriteOutMediumFactory.type</code> is used)</td>
</tr>
<tr>
<td><code>intermediateHandoffPeriod</code></td>
<td>ISO8601 Period</td>
<td>How often the tasks should hand off segments. Handoff will happen either if <code>maxRowsPerSegment</code> or <code>maxTotalRows</code> is hit or every <code>intermediateHandoffPeriod</code>, whichever happens earlier.</td>
<td>no (default == P2147483647D)</td>
</tr>
<tr>
<td><code>logParseExceptions</code></td>
<td>Boolean</td>
<td>If true, log an error message when a parsing exception occurs, containing information about the row where the error occurred.</td>
<td>no, default == false</td>
</tr>
<tr>
<td><code>maxParseExceptions</code></td>
<td>Integer</td>
<td>The maximum number of parse exceptions that can occur before the task halts ingestion and fails. Overridden if <code>reportParseExceptions</code> is set.</td>
<td>no, unlimited default</td>
</tr>
<tr>
<td><code>maxSavedParseExceptions</code></td>
<td>Integer</td>
<td>When a parse exception occurs, Druid can keep track of the most recent parse exceptions. &quot;maxSavedParseExceptions&quot; limits how many exception instances will be saved. These saved exceptions will be made available after the task finishes in the <a href="../../ingestion/reports.html">task completion report</a>. Overridden if <code>reportParseExceptions</code> is set.</td>
<td>no, default == 0</td>
</tr>
</tbody></table>

<h4 id="indexspec">IndexSpec</h4>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td>bitmap</td>
<td>Object</td>
<td>Compression format for bitmap indexes. Should be a JSON object; see below for options.</td>
<td>no (defaults to Concise)</td>
</tr>
<tr>
<td>dimensionCompression</td>
<td>String</td>
<td>Compression format for dimension columns. Choose from <code>LZ4</code>, <code>LZF</code>, or <code>uncompressed</code>.</td>
<td>no (default == <code>LZ4</code>)</td>
</tr>
<tr>
<td>metricCompression</td>
<td>String</td>
<td>Compression format for metric columns. Choose from <code>LZ4</code>, <code>LZF</code>, <code>uncompressed</code>, or <code>none</code>.</td>
<td>no (default == <code>LZ4</code>)</td>
</tr>
<tr>
<td>longEncoding</td>
<td>String</td>
<td>Encoding format for metric and dimension columns with type long. Choose from <code>auto</code> or <code>longs</code>. <code>auto</code> encodes the values using offset or lookup table depending on column cardinality, and store them with variable size. <code>longs</code> stores the value as is with 8 bytes each.</td>
<td>no (default == <code>longs</code>)</td>
</tr>
</tbody></table>

<h5 id="bitmap-types">Bitmap types</h5>

<p>For Concise bitmaps:</p>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>type</code></td>
<td>String</td>
<td>Must be <code>concise</code>.</td>
<td>yes</td>
</tr>
</tbody></table>

<p>For Roaring bitmaps:</p>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>type</code></td>
<td>String</td>
<td>Must be <code>roaring</code>.</td>
<td>yes</td>
</tr>
<tr>
<td><code>compressRunOnSerialization</code></td>
<td>Boolean</td>
<td>Use a run-length encoding where it is estimated as more space efficient.</td>
<td>no (default == <code>true</code>)</td>
</tr>
</tbody></table>

<h4 id="segmentwriteoutmediumfactory">SegmentWriteOutMediumFactory</h4>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>type</code></td>
<td>String</td>
<td>See <a href="../../configuration/index.html#segmentwriteoutmediumfactory">Additional Peon Configuration: SegmentWriteOutMediumFactory</a> for explanation and available options.</td>
<td>yes</td>
</tr>
</tbody></table>

<h3 id="kafkasupervisorioconfig">KafkaSupervisorIOConfig</h3>

<table><thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead><tbody>
<tr>
<td><code>topic</code></td>
<td>String</td>
<td>The Kafka topic to read from. This must be a specific topic as topic patterns are not supported.</td>
<td>yes</td>
</tr>
<tr>
<td><code>consumerProperties</code></td>
<td>Map<String, Object></td>
<td>A map of properties to be passed to the Kafka consumer. This must contain a property <code>bootstrap.servers</code> with a list of Kafka brokers in the form: <code>&lt;BROKER_1&gt;:&lt;PORT_1&gt;,&lt;BROKER_2&gt;:&lt;PORT_2&gt;,...</code>. For SSL connections, the <code>keystore</code>, <code>truststore</code> and <code>key</code> passwords can be provided as a <a href="../../operations/password-provider.html">Password Provider</a> or String password.</td>
<td>yes</td>
</tr>
<tr>
<td><code>pollTimeout</code></td>
<td>Long</td>
<td>The length of time to wait for the kafka consumer to poll records, in milliseconds</td>
<td>no (default == 100)</td>
</tr>
<tr>
<td><code>replicas</code></td>
<td>Integer</td>
<td>The number of replica sets, where 1 means a single set of tasks (no replication). Replica tasks will always be assigned to different workers to provide resiliency against process failure.</td>
<td>no (default == 1)</td>
</tr>
<tr>
<td><code>taskCount</code></td>
<td>Integer</td>
<td>The maximum number of <em>reading</em> tasks in a <em>replica set</em>. This means that the maximum number of reading tasks will be <code>taskCount * replicas</code> and the total number of tasks (<em>reading</em> + <em>publishing</em>) will be higher than this. See &#39;Capacity Planning&#39; below for more details. The number of reading tasks will be less than <code>taskCount</code> if <code>taskCount &gt; {numKafkaPartitions}</code>.</td>
<td>no (default == 1)</td>
</tr>
<tr>
<td><code>taskDuration</code></td>
<td>ISO8601 Period</td>
<td>The length of time before tasks stop reading and begin publishing their segment.</td>
<td>no (default == PT1H)</td>
</tr>
<tr>
<td><code>startDelay</code></td>
<td>ISO8601 Period</td>
<td>The period to wait before the supervisor starts managing tasks.</td>
<td>no (default == PT5S)</td>
</tr>
<tr>
<td><code>period</code></td>
<td>ISO8601 Period</td>
<td>How often the supervisor will execute its management logic. Note that the supervisor will also run in response to certain events (such as tasks succeeding, failing, and reaching their taskDuration) so this value specifies the maximum time between iterations.</td>
<td>no (default == PT30S)</td>
</tr>
<tr>
<td><code>useEarliestOffset</code></td>
<td>Boolean</td>
<td>If a supervisor is managing a dataSource for the first time, it will obtain a set of starting offsets from Kafka. This flag determines whether it retrieves the earliest or latest offsets in Kafka. Under normal circumstances, subsequent tasks will start from where the previous segments ended so this flag will only be used on first run.</td>
<td>no (default == false)</td>
</tr>
<tr>
<td><code>completionTimeout</code></td>
<td>ISO8601 Period</td>
<td>The length of time to wait before declaring a publishing task as failed and terminating it. If this is set too low, your tasks may never publish. The publishing clock for a task begins roughly after <code>taskDuration</code> elapses.</td>
<td>no (default == PT30M)</td>
</tr>
<tr>
<td><code>lateMessageRejectionPeriod</code></td>
<td>ISO8601 Period</td>
<td>Configure tasks to reject messages with timestamps earlier than this period before the task was created; for example if this is set to <code>PT1H</code> and the supervisor creates a task at <em>2016-01-01T12:00Z</em>, messages with timestamps earlier than <em>2016-01-01T11:00Z</em> will be dropped. This may help prevent concurrency issues if your data stream has late messages and you have multiple pipelines that need to operate on the same segments (e.g. a realtime and a nightly batch ingestion pipeline).</td>
<td>no (default == none)</td>
</tr>
<tr>
<td><code>earlyMessageRejectionPeriod</code></td>
<td>ISO8601 Period</td>
<td>Configure tasks to reject messages with timestamps later than this period after the task reached its taskDuration; for example if this is set to <code>PT1H</code>, the taskDuration is set to <code>PT1H</code> and the supervisor creates a task at <em>2016-01-01T12:00Z</em>, messages with timestamps later than <em>2016-01-01T14:00Z</em> will be dropped. <strong>Note:</strong> Tasks sometimes run past their task duration, for example, in cases of supervisor failover. Setting earlyMessageRejectionPeriod too low may cause messages to be dropped unexpectedly whenever a task runs past its originally configured task duration.</td>
<td>no (default == none)</td>
</tr>
<tr>
<td><code>skipOffsetGaps</code></td>
<td>Boolean</td>
<td>Whether or not to allow gaps of missing offsets in the Kafka stream. This is required for compatibility with implementations such as MapR Streams which does not guarantee consecutive offsets. If this is false, an exception will be thrown if offsets are not consecutive.</td>
<td>no (default == false)</td>
</tr>
</tbody></table>

<h2 id="operations">Operations</h2>

<p>This section gives descriptions of how some supervisor APIs work specifically in Kafka Indexing Service.
For all supervisor APIs, please check <a href="../../operations/api-reference.html#supervisors">Supervisor APIs</a>.</p>

<h3 id="getting-supervisor-status-report">Getting Supervisor Status Report</h3>

<p><code>GET /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/status</code> returns a snapshot report of the current state of the tasks managed by the given supervisor. This includes the latest
offsets as reported by Kafka, the consumer lag per partition, as well as the aggregate lag of all partitions. The
consumer lag per partition may be reported as negative values if the supervisor has not received a recent latest offset
response from Kafka. The aggregate lag value will always be &gt;= 0.</p>

<h3 id="getting-supervisor-ingestion-stats-report">Getting Supervisor Ingestion Stats Report</h3>

<p><code>GET /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/stats</code> returns a snapshot of the current ingestion row counters for each task being managed by the supervisor, along with moving averages for the row counters.</p>

<p>See <a href="../../ingestion/reports.html#row-stats">Task Reports: Row Stats</a> for more information.</p>

<h3 id="updating-existing-supervisors">Updating Existing Supervisors</h3>

<p><code>POST /druid/indexer/v1/supervisor</code> can be used to update existing supervisor spec.
Calling this endpoint when there is already an existing supervisor for the same dataSource will cause:</p>

<ul>
<li>The running supervisor to signal its managed tasks to stop reading and begin publishing.</li>
<li>The running supervisor to exit.</li>
<li>A new supervisor to be created using the configuration provided in the request body. This supervisor will retain the
existing publishing tasks and will create new tasks starting at the offsets the publishing tasks ended on.</li>
</ul>

<p>Seamless schema migrations can thus be achieved by simply submitting the new schema using this endpoint.</p>

<h3 id="suspending-and-resuming-supervisors">Suspending and Resuming Supervisors</h3>

<p>You can suspend and resume a supervisor using <code>POST /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/suspend</code> and <code>POST /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/resume</code>, respectively.</p>

<p>Note that the supervisor itself will still be operating and emitting logs and metrics,
it will just ensure that no indexing tasks are running until the supervisor is resumed.</p>

<h3 id="resetting-supervisors">Resetting Supervisors</h3>

<p>To reset a running supervisor, you can use <code>POST /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/reset</code>.</p>

<p>The indexing service keeps track of the latest persisted Kafka offsets in order to provide exactly-once ingestion
guarantees across tasks. Subsequent tasks must start reading from where the previous task completed in order for the
generated segments to be accepted. If the messages at the expected starting offsets are no longer available in Kafka
(typically because the message retention period has elapsed or the topic was removed and re-created) the supervisor will
refuse to start and in-flight tasks will fail.</p>

<p>This endpoint can be used to clear the stored offsets which will cause the supervisor to start reading from
either the earliest or latest offsets in Kafka (depending on the value of <code>useEarliestOffset</code>). The supervisor must be
running for this endpoint to be available. After the stored offsets are cleared, the supervisor will automatically kill
and re-create any active tasks so that tasks begin reading from valid offsets.</p>

<p>Note that since the stored offsets are necessary to guarantee exactly-once ingestion, resetting them with this endpoint
may cause some Kafka messages to be skipped or to be read twice.</p>

<h3 id="terminating-supervisors">Terminating Supervisors</h3>

<p><code>POST /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/terminate</code> terminates a supervisor and causes all associated indexing
tasks managed by this supervisor to immediately stop and begin
publishing their segments. This supervisor will still exist in the metadata store and it&#39;s history may be retrieved
with the supervisor history api, but will not be listed in the &#39;get supervisors&#39; api response nor can it&#39;s configuration
or status report be retrieved. The only way this supervisor can start again is by submitting a functioning supervisor
spec to the create api.</p>

<h3 id="capacity-planning">Capacity Planning</h3>

<p>Kafka indexing tasks run on MiddleManagers and are thus limited by the resources available in the MiddleManager
cluster. In particular, you should make sure that you have sufficient worker capacity (configured using the
<code>druid.worker.capacity</code> property) to handle the configuration in the supervisor spec. Note that worker capacity is
shared across all types of indexing tasks, so you should plan your worker capacity to handle your total indexing load
(e.g. batch processing, realtime tasks, merging tasks, etc.). If your workers run out of capacity, Kafka indexing tasks
will queue and wait for the next available worker. This may cause queries to return partial results but will not result
in data loss (assuming the tasks run before Kafka purges those offsets).</p>

<p>A running task will normally be in one of two states: <em>reading</em> or <em>publishing</em>. A task will remain in reading state for
<code>taskDuration</code>, at which point it will transition to publishing state. A task will remain in publishing state for as long
as it takes to generate segments, push segments to deep storage, and have them be loaded and served by a Historical process
(or until <code>completionTimeout</code> elapses).</p>

<p>The number of reading tasks is controlled by <code>replicas</code> and <code>taskCount</code>. In general, there will be <code>replicas * taskCount</code>
reading tasks, the exception being if taskCount &gt; {numKafkaPartitions} in which case {numKafkaPartitions} tasks will
be used instead. When <code>taskDuration</code> elapses, these tasks will transition to publishing state and <code>replicas * taskCount</code>
new reading tasks will be created. Therefore to allow for reading tasks and publishing tasks to run concurrently, there
should be a minimum capacity of:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"><span></span>workerCapacity = 2 * replicas * taskCount
</code></pre></div>
<p>This value is for the ideal situation in which there is at most one set of tasks publishing while another set is reading.
In some circumstances, it is possible to have multiple sets of tasks publishing simultaneously. This would happen if the
time-to-publish (generate segment, push to deep storage, loaded on Historical) &gt; <code>taskDuration</code>. This is a valid
scenario (correctness-wise) but requires additional worker capacity to support. In general, it is a good idea to have
<code>taskDuration</code> be large enough that the previous set of tasks finishes publishing before the current set begins.</p>

<h3 id="supervisor-persistence">Supervisor Persistence</h3>

<p>When a supervisor spec is submitted via the <code>POST /druid/indexer/v1/supervisor</code> endpoint, it is persisted in the
configured metadata database. There can only be a single supervisor per dataSource, and submitting a second spec for
the same dataSource will overwrite the previous one.</p>

<p>When an Overlord gains leadership, either by being started or as a result of another Overlord failing, it will spawn
a supervisor for each supervisor spec in the metadata database. The supervisor will then discover running Kafka indexing
tasks and will attempt to adopt them if they are compatible with the supervisor&#39;s configuration. If they are not
compatible because they have a different ingestion spec or partition allocation, the tasks will be killed and the
supervisor will create a new set of tasks. In this way, the supervisors are persistent across Overlord restarts and
fail-overs.</p>

<p>A supervisor is stopped via the <code>POST /druid/indexer/v1/supervisor/&lt;supervisorId&gt;/terminate</code> endpoint. This places a
tombstone marker in the database (to prevent the supervisor from being reloaded on a restart) and then gracefully
shuts down the currently running supervisor. When a supervisor is shut down in this way, it will instruct its
managed tasks to stop reading and begin publishing their segments immediately. The call to the shutdown endpoint will
return after all tasks have been signalled to stop but before the tasks finish publishing their segments.</p>

<h3 id="schema-configuration-changes">Schema/Configuration Changes</h3>

<p>Schema and configuration changes are handled by submitting the new supervisor spec via the same
<code>POST /druid/indexer/v1/supervisor</code> endpoint used to initially create the supervisor. The Overlord will initiate a
graceful shutdown of the existing supervisor which will cause the tasks being managed by that supervisor to stop reading
and begin publishing their segments. A new supervisor will then be started which will create a new set of tasks that
will start reading from the offsets where the previous now-publishing tasks left off, but using the updated schema.
In this way, configuration changes can be applied without requiring any pause in ingestion.</p>

<h3 id="deployment-notes">Deployment Notes</h3>

<h4 id="on-the-subject-of-segments">On the Subject of Segments</h4>

<p>Each Kafka Indexing Task puts events consumed from Kafka partitions assigned to it in a single segment for each segment
granular interval until maxRowsPerSegment, maxTotalRows or intermediateHandoffPeriod limit is reached, at this point a new partition
for this segment granularity is created for further events. Kafka Indexing Task also does incremental hand-offs which
means that all the segments created by a task will not be held up till the task duration is over. As soon as maxRowsPerSegment,
maxTotalRows or intermediateHandoffPeriod limit is hit, all the segments held by the task at that point in time will be handed-off
and new set of segments will be created for further events. This means that the task can run for longer durations of time
without accumulating old segments locally on Middle Manager processes and it is encouraged to do so.</p>

<p>Kafka Indexing Service may still produce some small segments. Lets say the task duration is 4 hours, segment granularity
is set to an HOUR and Supervisor was started at 9:10 then after 4 hours at 13:10, new set of tasks will be started and
events for the interval 13:00 - 14:00 may be split across previous and new set of tasks. If you see it becoming a problem then
one can schedule re-indexing tasks be run to merge segments together into new segments of an ideal size (in the range of ~500-700 MB per segment).
Details on how to optimize the segment size can be found on <a href="../../operations/segment-optimization.html">Segment size optimization</a>.
There is also ongoing work to support automatic segment compaction of sharded segments as well as compaction not requiring
Hadoop (see <a href="https://github.com/apache/incubator-druid/pull/5102">here</a>).</p>

        </div>
        <div class="col-md-3">
          <div class="searchbox">
            <gcse:searchbox-only></gcse:searchbox-only>
          </div>
          <div id="toc" class="nav toc hidden-print">
          </div>
        </div>
      </div>
    </div>

    <!-- Start page_footer include -->
<footer class="druid-footer">
<div class="container">
  <div class="text-center">
    <p>
    <a href="/technology">Technology</a>&ensp;·&ensp;
    <a href="/use-cases">Use Cases</a>&ensp;·&ensp;
    <a href="/druid-powered">Powered by Druid</a>&ensp;·&ensp;
    <a href="/docs/latest/">Docs</a>&ensp;·&ensp;
    <a href="/community/">Community</a>&ensp;·&ensp;
    <a href="/downloads.html">Download</a>&ensp;·&ensp;
    <a href="/faq">FAQ</a>
    </p>
  </div>
  <div class="text-center">
    <a title="Join the user group" href="https://groups.google.com/forum/#!forum/druid-user" target="_blank"><span class="fa fa-comments"></span></a>&ensp;·&ensp;
    <a title="Follow Druid" href="https://twitter.com/druidio" target="_blank"><span class="fab fa-twitter"></span></a>&ensp;·&ensp;
    <a title="GitHub" href="https://github.com/apache/druid" target="_blank"><span class="fab fa-github"></span></a>
  </div>
  <div class="text-center license">
    Copyright © 2020 <a href="https://www.apache.org/" target="_blank">Apache Software Foundation</a>.<br>
    Except where otherwise noted, licensed under <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.<br>
    Apache Druid, Druid, and the Druid logo are either registered trademarks or trademarks of The Apache Software Foundation in the United States and other countries.
  </div>
</div>
</footer>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131010415-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-131010415-1');
</script>
<script>
  function trackDownload(type, url) {
    ga('send', 'event', 'download', type, url);
  }
</script>
<script src="//code.jquery.com/jquery.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="/assets/js/druid.js"></script>
<!-- stop page_footer include -->


    <script>
    $(function() {
      $(".toc").load("/docs/0.14.2-incubating/toc.html");

      // There is no way to tell when .gsc-input will be async loaded into the page so just try to set a placeholder until it works
      var tries = 0;
      var timer = setInterval(function() {
        tries++;
        if (tries > 300) clearInterval(timer);
        var searchInput = $('input.gsc-input');
        if (searchInput.length) {
          searchInput.attr('placeholder', 'Search');
          clearInterval(timer);
        }
      }, 100);
    });
    </script>
  </body>
</html>
