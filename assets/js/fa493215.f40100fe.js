"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9934],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>c});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),g=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=g(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=g(a),d=r,c=m["".concat(s,".").concat(d)]||m[d]||p[d]||o;return a?n.createElement(c,i(i({ref:t},u),{},{components:a})):n.createElement(c,i({ref:t},u))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var g=2;g<o;g++)i[g]=a[g];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},28151:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>g,toc:()=>m});var n=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],l={id:"aggregations",title:"Aggregations"},s=void 0,g={unversionedId:"querying/aggregations",id:"querying/aggregations",title:"Aggregations",description:"\x3c!--",source:"@site/docs/latest/querying/aggregations.md",sourceDirName:"querying",slug:"/querying/aggregations",permalink:"/docs/latest/querying/aggregations",draft:!1,tags:[],version:"current",frontMatter:{id:"aggregations",title:"Aggregations"},sidebar:"docs",previous:{title:"Dimensions",permalink:"/docs/latest/querying/dimensionspecs"},next:{title:"Post-aggregations",permalink:"/docs/latest/querying/post-aggregations"}},u={},m=[{value:"Exact aggregations",id:"exact-aggregations",level:2},{value:"Count aggregator",id:"count-aggregator",level:3},{value:"Sum aggregators",id:"sum-aggregators",level:3},{value:"<code>longSum</code> aggregator",id:"longsum-aggregator",level:4},{value:"<code>doubleSum</code> aggregator",id:"doublesum-aggregator",level:4},{value:"<code>floatSum</code> aggregator",id:"floatsum-aggregator",level:4},{value:"Min and max aggregators",id:"min-and-max-aggregators",level:3},{value:"<code>doubleMin</code> aggregator",id:"doublemin-aggregator",level:4},{value:"<code>doubleMax</code> aggregator",id:"doublemax-aggregator",level:4},{value:"<code>floatMin</code> aggregator",id:"floatmin-aggregator",level:4},{value:"<code>floatMax</code> aggregator",id:"floatmax-aggregator",level:4},{value:"<code>longMin</code> aggregator",id:"longmin-aggregator",level:4},{value:"<code>longMax</code> aggregator",id:"longmax-aggregator",level:4},{value:"<code>doubleMean</code> aggregator",id:"doublemean-aggregator",level:3},{value:"First and last aggregators",id:"first-and-last-aggregators",level:3},{value:"<code>doubleFirst</code> aggregator",id:"doublefirst-aggregator",level:4},{value:"<code>doubleLast</code> aggregator",id:"doublelast-aggregator",level:4},{value:"<code>floatFirst</code> aggregator",id:"floatfirst-aggregator",level:4},{value:"<code>floatLast</code> aggregator",id:"floatlast-aggregator",level:4},{value:"<code>longFirst</code> aggregator",id:"longfirst-aggregator",level:4},{value:"<code>longLast</code> aggregator",id:"longlast-aggregator",level:4},{value:"<code>stringFirst</code> aggregator",id:"stringfirst-aggregator",level:4},{value:"<code>stringLast</code> aggregator",id:"stringlast-aggregator",level:4},{value:"ANY aggregators",id:"any-aggregators",level:3},{value:"<code>doubleAny</code> aggregator",id:"doubleany-aggregator",level:4},{value:"<code>floatAny</code> aggregator",id:"floatany-aggregator",level:4},{value:"<code>longAny</code> aggregator",id:"longany-aggregator",level:4},{value:"<code>stringAny</code> aggregator",id:"stringany-aggregator",level:4},{value:"JavaScript aggregator",id:"javascript-aggregator",level:3},{value:"Approximate aggregations",id:"approximate-aggregations",level:2},{value:"Count distinct",id:"count-distinct",level:3},{value:"Apache DataSketches Theta Sketch",id:"apache-datasketches-theta-sketch",level:4},{value:"Apache DataSketches HLL Sketch",id:"apache-datasketches-hll-sketch",level:4},{value:"Cardinality, hyperUnique",id:"cardinality-hyperunique",level:4},{value:"Multi-column handling",id:"multi-column-handling",level:5},{value:"Histograms and quantiles",id:"histograms-and-quantiles",level:3},{value:"DataSketches Quantiles Sketch",id:"datasketches-quantiles-sketch",level:4},{value:"Moments Sketch (Experimental)",id:"moments-sketch-experimental",level:4},{value:"Fixed Buckets Histogram",id:"fixed-buckets-histogram",level:4},{value:"Approximate Histogram (deprecated)",id:"approximate-histogram-deprecated",level:4},{value:"Miscellaneous aggregations",id:"miscellaneous-aggregations",level:2},{value:"Filtered aggregator",id:"filtered-aggregator",level:3},{value:"Grouping aggregator",id:"grouping-aggregator",level:3}],p={toc:m},d="wrapper";function c(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Apache Druid supports two query languages: ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/querying/sql"},"Druid SQL")," and ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/querying/"},"native queries"),".\nThis document describes the native\nlanguage. For information about aggregators available in SQL, refer to the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/querying/sql-aggregations"},"SQL documentation"),".")),(0,o.kt)("p",null,"You can use aggregations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"in the ingestion spec during ingestion to summarize data before it enters Apache Druid."),(0,o.kt)("li",{parentName:"ul"},"at query time to summarize result data.")),(0,o.kt)("p",null,"The following sections list the available aggregate functions. Unless otherwise noted, aggregations are available at both ingestion and query time."),(0,o.kt)("h2",{id:"exact-aggregations"},"Exact aggregations"),(0,o.kt)("h3",{id:"count-aggregator"},"Count aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"count")," computes the count of Druid rows that match the filters."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "count", "name" : <output_name> }\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," aggregator counts the number of Druid rows, which does not always reflect the number of raw events ingested.\nThis is because Druid can be configured to roll up data at ingestion time. To\ncount the number of ingested rows of data, include a ",(0,o.kt)("inlineCode",{parentName:"p"},"count")," aggregator at ingestion time and a ",(0,o.kt)("inlineCode",{parentName:"p"},"longSum")," aggregator at\nquery time."),(0,o.kt)("h3",{id:"sum-aggregators"},"Sum aggregators"),(0,o.kt)("h4",{id:"longsum-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longSum")," aggregator"),(0,o.kt)("p",null,"Computes the sum of values as a 64-bit, signed integer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "longSum", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"longSum")," aggregator takes the following properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name"),": Output name for the summed value"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"fieldName"),": Name of the metric column to sum over")),(0,o.kt)("h4",{id:"doublesum-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleSum")," aggregator"),(0,o.kt)("p",null,"Computes and stores the sum of values as a 64-bit floating point value. Similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"longSum"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "doubleSum", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"floatsum-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatSum")," aggregator"),(0,o.kt)("p",null,"Computes and stores the sum of values as a 32-bit floating point value. Similar to ",(0,o.kt)("inlineCode",{parentName:"p"},"longSum")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"doubleSum"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "floatSum", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h3",{id:"min-and-max-aggregators"},"Min and max aggregators"),(0,o.kt)("h4",{id:"doublemin-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleMin")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doubleMin")," computes the minimum of all metric values and Double.POSITIVE_INFINITY."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "doubleMin", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"doublemax-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleMax")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doubleMax")," computes the maximum of all metric values and Double.NEGATIVE_INFINITY."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "doubleMax", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"floatmin-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatMin")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"floatMin")," computes the minimum of all metric values and Float.POSITIVE_INFINITY."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "floatMin", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"floatmax-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatMax")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"floatMax")," computes the maximum of all metric values and Float.NEGATIVE_INFINITY."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "floatMax", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"longmin-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longMin")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"longMin")," computes the minimum of all metric values and Long.MAX_VALUE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "longMin", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h4",{id:"longmax-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longMax")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"longMax")," computes the maximum of all metric values and Long.MIN_VALUE."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "longMax", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h3",{id:"doublemean-aggregator"},(0,o.kt)("inlineCode",{parentName:"h3"},"doubleMean")," aggregator"),(0,o.kt)("p",null,"Computes and returns the arithmetic mean of a column's values as a 64-bit floating point value. ",(0,o.kt)("inlineCode",{parentName:"p"},"doubleMean")," is a query time aggregator only. It is not available for indexing."),(0,o.kt)("p",null,"To accomplish mean aggregation on ingestion, refer to the ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-quantiles#aggregator"},"Quantiles aggregator")," from the DataSketches extension."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "doubleMean", "name" : <output_name>, "fieldName" : <metric_name> }\n')),(0,o.kt)("h3",{id:"first-and-last-aggregators"},"First and last aggregators"),(0,o.kt)("p",null,"The first and last aggregators determine the metric values that respectively correspond to the earliest and latest values of a time column."),(0,o.kt)("p",null,"Do not use first and last aggregators for the double, float, and long types in an ingestion spec. They are only supported for queries.\nThe string-typed aggregators, ",(0,o.kt)("inlineCode",{parentName:"p"},"stringFirst")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"stringLast"),", are supported for both ingestion and querying."),(0,o.kt)("p",null,"Queries with first or last aggregators on a segment created with rollup return the rolled up value, not the first or last value from the raw ingested data."),(0,o.kt)("h4",{id:"doublefirst-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleFirst")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doubleFirst")," computes the metric value with the minimum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "doubleFirst",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"doublelast-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleLast")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doubleLast")," computes the metric value with the maximum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "doubleLast",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"floatfirst-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatFirst")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"floatFirst")," computes the metric value with the minimum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "floatFirst",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"floatlast-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatLast")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"floatLast")," computes the metric value with the maximum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "floatLast",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"longfirst-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longFirst")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"longFirst")," computes the metric value with the minimum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "longFirst",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"longlast-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longLast")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"longLast")," computes the metric value with the maximum value for time column or 0 in default mode, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," in SQL-compatible mode if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "longLast",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"stringfirst-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"stringFirst")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stringFirst")," computes the metric value with the minimum value for time column or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "stringFirst",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "maxStringBytes" : <integer> # (optional, defaults to 1024)\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h4",{id:"stringlast-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"stringLast")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stringLast")," computes the metric value with the maximum value for time column or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if no row exists."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "stringLast",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "maxStringBytes" : <integer> # (optional, defaults to 1024)\n  "timeColumn" : <time_column_name> # (optional, defaults to __time)\n}\n')),(0,o.kt)("h3",{id:"any-aggregators"},"ANY aggregators"),(0,o.kt)("p",null,"(Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries."),(0,o.kt)("p",null,"Returns any value including null. This aggregator can simplify and optimize the performance by returning the first encountered value (including null)"),(0,o.kt)("h4",{id:"doubleany-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"doubleAny")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"doubleAny")," returns any double metric value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "doubleAny",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>\n}\n')),(0,o.kt)("h4",{id:"floatany-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"floatAny")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"floatAny")," returns any float metric value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "floatAny",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>\n}\n')),(0,o.kt)("h4",{id:"longany-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"longAny")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"longAny")," returns any long metric value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "longAny",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n}\n')),(0,o.kt)("h4",{id:"stringany-aggregator"},(0,o.kt)("inlineCode",{parentName:"h4"},"stringAny")," aggregator"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stringAny")," returns any string metric value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "stringAny",\n  "name" : <output_name>,\n  "fieldName" : <metric_name>,\n  "maxStringBytes" : <integer> # (optional, defaults to 1024),\n}\n')),(0,o.kt)("h3",{id:"javascript-aggregator"},"JavaScript aggregator"),(0,o.kt)("p",null,"Computes an arbitrary JavaScript function over a set of columns (both metrics and dimensions are allowed). Your\nJavaScript functions are expected to return floating-point values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type": "javascript",\n  "name": "<output_name>",\n  "fieldNames"  : [ <column1>, <column2>, ... ],\n  "fnAggregate" : "function(current, column1, column2, ...) {\n                     <updates partial aggregate (current) based on the current row values>\n                     return <updated partial aggregate>\n                   }",\n  "fnCombine"   : "function(partialA, partialB) { return <combined partial results>; }",\n  "fnReset"     : "function()                   { return <initial value>; }"\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "javascript",\n  "name": "sum(log(x)*y) + 10",\n  "fieldNames": ["x", "y"],\n  "fnAggregate" : "function(current, a, b)      { return current + (Math.log(a) * b); }",\n  "fnCombine"   : "function(partialA, partialB) { return partialA + partialB; }",\n  "fnReset"     : "function()                   { return 10; }"\n}\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"JavaScript-based functionality is disabled by default. Please refer to the Druid ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/javascript"},"JavaScript programming guide")," for guidelines about using Druid's JavaScript functionality, including instructions on how to enable it.")),(0,o.kt)("a",{name:"approx"}),(0,o.kt)("h2",{id:"approximate-aggregations"},"Approximate aggregations"),(0,o.kt)("h3",{id:"count-distinct"},"Count distinct"),(0,o.kt)("h4",{id:"apache-datasketches-theta-sketch"},"Apache DataSketches Theta Sketch"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-theta"},"DataSketches Theta Sketch")," extension-provided aggregator gives distinct count estimates with support for set union, intersection, and difference post-aggregators, using Theta sketches from the ",(0,o.kt)("a",{parentName:"p",href:"https://datasketches.apache.org/"},"Apache DataSketches")," library."),(0,o.kt)("h4",{id:"apache-datasketches-hll-sketch"},"Apache DataSketches HLL Sketch"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-hll"},"DataSketches HLL Sketch")," extension-provided aggregator gives distinct count estimates using the HyperLogLog algorithm."),(0,o.kt)("p",null,"Compared to the Theta sketch, the HLL sketch does not support set operations and has slightly slower update and merge speed, but requires significantly less space."),(0,o.kt)("h4",{id:"cardinality-hyperunique"},"Cardinality, hyperUnique"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"For new use cases, we recommend evaluating ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-theta"},"DataSketches Theta Sketch")," or ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-hll"},"DataSketches HLL Sketch")," instead.\nThe DataSketches aggregators are generally able to offer more flexibility and better accuracy than the classic Druid ",(0,o.kt)("inlineCode",{parentName:"p"},"cardinality")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"hyperUnique")," aggregators.")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/querying/hll-old"},"Cardinality and HyperUnique")," aggregators are older aggregator implementations available by default in Druid that also provide distinct count estimates using the HyperLogLog algorithm. The newer DataSketches Theta and HLL extension-provided aggregators described above have superior accuracy and performance and are recommended instead."),(0,o.kt)("p",null,"The DataSketches team has published a ",(0,o.kt)("a",{parentName:"p",href:"https://datasketches.apache.org/docs/HLL/HllSketchVsDruidHyperLogLogCollector.html"},"comparison study")," between Druid's original HLL algorithm and the DataSketches HLL algorithm. Based on the demonstrated advantages of the DataSketches implementation, we are recommending using them in preference to Druid's original HLL-based aggregators.\nHowever, to ensure backwards compatibility, we will continue to support the classic aggregators."),(0,o.kt)("p",null,"Please note that ",(0,o.kt)("inlineCode",{parentName:"p"},"hyperUnique")," aggregators are not mutually compatible with Datasketches HLL or Theta sketches."),(0,o.kt)("h5",{id:"multi-column-handling"},"Multi-column handling"),(0,o.kt)("p",null,"Note the DataSketches Theta and HLL aggregators currently only support single-column inputs. If you were previously using the Cardinality aggregator with multiple-column inputs, equivalent operations using Theta or HLL sketches are described below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Multi-column ",(0,o.kt)("inlineCode",{parentName:"li"},"byValue")," Cardinality can be replaced with a union of Theta sketches on the individual input columns"),(0,o.kt)("li",{parentName:"ul"},"Multi-column ",(0,o.kt)("inlineCode",{parentName:"li"},"byRow")," Cardinality can be replaced with a Theta or HLL sketch on a single ",(0,o.kt)("a",{parentName:"li",href:"/docs/latest/querying/virtual-columns"},"virtual column")," that combines the individual input columns.")),(0,o.kt)("h3",{id:"histograms-and-quantiles"},"Histograms and quantiles"),(0,o.kt)("h4",{id:"datasketches-quantiles-sketch"},"DataSketches Quantiles Sketch"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-quantiles"},"DataSketches Quantiles Sketch")," extension-provided aggregator provides quantile estimates and histogram approximations using the numeric quantiles DoublesSketch from the ",(0,o.kt)("a",{parentName:"p",href:"https://datasketches.apache.org/"},"datasketches")," library."),(0,o.kt)("p",null,"We recommend this aggregator in general for quantiles/histogram use cases, as it provides formal error bounds and has distribution-independent accuracy."),(0,o.kt)("h4",{id:"moments-sketch-experimental"},"Moments Sketch (Experimental)"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-contrib/momentsketch-quantiles"},"Moments Sketch")," extension-provided aggregator is an experimental aggregator that provides quantile estimates using the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/stanford-futuredata/momentsketch"},"Moments Sketch"),"."),(0,o.kt)("p",null,"The Moments Sketch aggregator is provided as an experimental option. It is optimized for merging speed and it can have higher aggregation performance compared to the DataSketches quantiles aggregator. However, the accuracy of the Moments Sketch is distribution-dependent, so users will need to empirically verify that the aggregator is suitable for their input data."),(0,o.kt)("p",null,"As a general guideline for experimentation, the ",(0,o.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1803.01969.pdf"},"Moments Sketch paper")," points out that this algorithm works better on inputs with high entropy. In particular, the algorithm is not a good fit when the input data consists of a small number of clustered discrete values."),(0,o.kt)("h4",{id:"fixed-buckets-histogram"},"Fixed Buckets Histogram"),(0,o.kt)("p",null,"Druid also provides a ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/approximate-histograms#fixed-buckets-histogram"},"simple histogram implementation")," that uses a fixed range and fixed number of buckets with support for quantile estimation, backed by an array of bucket count values."),(0,o.kt)("p",null,"The fixed buckets histogram can perform well when the distribution of the input data allows a small number of buckets to be used."),(0,o.kt)("p",null,"We do not recommend the fixed buckets histogram for general use, as its usefulness is extremely data dependent. However, it is made available for users that have already identified use cases where a fixed buckets histogram is suitable."),(0,o.kt)("h4",{id:"approximate-histogram-deprecated"},"Approximate Histogram (deprecated)"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The Approximate Histogram aggregator is deprecated.\nThere are a number of other quantile estimation algorithms that offer better performance, accuracy, and memory footprint.\nWe recommend using ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/datasketches-quantiles"},"DataSketches Quantiles")," instead.")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/latest/development/extensions-core/approximate-histograms"},"Approximate Histogram")," extension-provided aggregator also provides quantile estimates and histogram approximations, based on ",(0,o.kt)("a",{parentName:"p",href:"http://jmlr.org/papers/volume11/ben-haim10a/ben-haim10a.pdf"},"http://jmlr.org/papers/volume11/ben-haim10a/ben-haim10a.pdf"),"."),(0,o.kt)("p",null,"The algorithm used by this deprecated aggregator is highly distribution-dependent and its output is subject to serious distortions when the input does not fit within the algorithm's limitations."),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"https://datasketches.apache.org/docs/QuantilesStudies/DruidApproxHistogramStudy.html"},"study published by the DataSketches team")," demonstrates some of the known failure modes of this algorithm:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The algorithm's quantile calculations can fail to provide results for a large range of rank values (all ranks less than 0.89 in the example used in the study), returning all zeroes instead."),(0,o.kt)("li",{parentName:"ul"},"The algorithm can completely fail to record spikes in the tail ends of the distribution"),(0,o.kt)("li",{parentName:"ul"},"In general, the histogram produced by the algorithm can deviate significantly from the true histogram, with no bounds on the errors.")),(0,o.kt)("p",null,"It is not possible to determine a priori how well this aggregator will behave for a given input stream, nor does the aggregator provide any indication that serious distortions are present in the output."),(0,o.kt)("p",null,"For these reasons, we have deprecated this aggregator and recommend using the DataSketches Quantiles aggregator instead for new and existing use cases, although we will continue to support Approximate Histogram for backwards compatibility."),(0,o.kt)("h2",{id:"miscellaneous-aggregations"},"Miscellaneous aggregations"),(0,o.kt)("h3",{id:"filtered-aggregator"},"Filtered aggregator"),(0,o.kt)("p",null,"A filtered aggregator wraps any given aggregator, but only aggregates the values for which the given dimension filter matches."),(0,o.kt)("p",null,"This makes it possible to compute the results of a filtered and an unfiltered aggregation simultaneously, without having to issue multiple queries, and use both results as part of post-aggregations."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note:")," If only the filtered results are required, consider putting the filter on the query itself, which will be much faster since it does not require scanning all the data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type" : "filtered",\n  "filter" : {\n    "type" : "selector",\n    "dimension" : <dimension>,\n    "value" : <dimension value>\n  },\n  "aggregator" : <aggregation>\n}\n')),(0,o.kt)("h3",{id:"grouping-aggregator"},"Grouping aggregator"),(0,o.kt)("p",null,"A grouping aggregator can only be used as part of GroupBy queries which have a subtotal spec. It returns a number for\neach output row that lets you infer whether a particular dimension is included in the sub-grouping used for that row. You can pass\na ",(0,o.kt)("em",{parentName:"p"},"non-empty")," list of dimensions to this aggregator which ",(0,o.kt)("em",{parentName:"p"},"must")," be a subset of dimensions that you are grouping on. "),(0,o.kt)("p",null,"For example, if the aggregator has ",(0,o.kt)("inlineCode",{parentName:"p"},'["dim1", "dim2"]')," as input dimensions and ",(0,o.kt)("inlineCode",{parentName:"p"},'[["dim1", "dim2"], ["dim1"], ["dim2"], []]')," as subtotals, the\npossible output of the aggregator is:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"subtotal used in query"),(0,o.kt)("th",{parentName:"tr",align:null},"Output"),(0,o.kt)("th",{parentName:"tr",align:null},"(bits representation)"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'["dim1", "dim2"]')),(0,o.kt)("td",{parentName:"tr",align:null},"0"),(0,o.kt)("td",{parentName:"tr",align:null},"(00)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'["dim1"]')),(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"(01)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},'["dim2"]')),(0,o.kt)("td",{parentName:"tr",align:null},"2"),(0,o.kt)("td",{parentName:"tr",align:null},"(10)")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"[]")),(0,o.kt)("td",{parentName:"tr",align:null},"3"),(0,o.kt)("td",{parentName:"tr",align:null},"(11)")))),(0,o.kt)("p",null,"As the example illustrates, you can think of the output number as an unsigned ",(0,o.kt)("em",{parentName:"p"},"n")," bit number where ",(0,o.kt)("em",{parentName:"p"},"n")," is the number of dimensions passed to the aggregator.\nDruid sets the bit at position X for the number to 0 if the sub-grouping includes a dimension at position X in the aggregator input. Otherwise, Druid sets this bit to 1."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{ "type" : "grouping", "name" : <output_name>, "groupings" : [<dimension>] }\n')))}c.isMDXComponent=!0}}]);