"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9466],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>f});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(r),h=o,f=p["".concat(c,".").concat(h)]||p[h]||d[h]||s;return r?n.createElement(f,a(a({ref:t},u),{},{components:r})):n.createElement(f,a({ref:t},u))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=r.length,a=new Array(s);a[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},75173:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var n=r(87462),o=r(63366),s=(r(67294),r(3905)),a=["components"],i={id:"broker",title:"Broker"},c=void 0,l={unversionedId:"design/broker",id:"design/broker",title:"Broker",description:"\x3c!--",source:"@site/docs/latest/design/broker.md",sourceDirName:"design",slug:"/design/broker",permalink:"/docs/latest/design/broker",draft:!1,tags:[],version:"current",frontMatter:{id:"broker",title:"Broker"}},u={},p=[{value:"Configuration",id:"configuration",level:3},{value:"HTTP endpoints",id:"http-endpoints",level:3},{value:"Overview",id:"overview",level:3},{value:"Running",id:"running",level:3},{value:"Forwarding queries",id:"forwarding-queries",level:3},{value:"Caching",id:"caching",level:3}],d={toc:p},h="wrapper";function f(e){var t=e.components,r=(0,o.Z)(e,a);return(0,s.kt)(h,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h3",{id:"configuration"},"Configuration"),(0,s.kt)("p",null,"For Apache Druid Broker Process Configuration, see ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/configuration/#broker"},"Broker Configuration"),"."),(0,s.kt)("p",null,"For basic tuning guidance for the Broker process, see ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/operations/basic-cluster-tuning#broker"},"Basic cluster tuning"),"."),(0,s.kt)("h3",{id:"http-endpoints"},"HTTP endpoints"),(0,s.kt)("p",null,"For a list of API endpoints supported by the Broker, see ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/operations/api-reference#broker"},"Broker API"),"."),(0,s.kt)("h3",{id:"overview"},"Overview"),(0,s.kt)("p",null,"The Broker is the process to route queries to if you want to run a distributed cluster. It understands the metadata published to ZooKeeper about what segments exist on what processes and routes queries such that they hit the right processes. This process also merges the result sets from all of the individual processes together.\nOn start up, Historical processes announce themselves and the segments they are serving in Zookeeper."),(0,s.kt)("h3",{id:"running"},"Running"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"org.apache.druid.cli.Main server broker\n")),(0,s.kt)("h3",{id:"forwarding-queries"},"Forwarding queries"),(0,s.kt)("p",null,"Most Druid queries contain an interval object that indicates a span of time for which data is requested. Likewise, Druid ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/design/segments"},"Segments")," are partitioned to contain data for some interval of time and segments are distributed across a cluster. Consider a simple datasource with 7 segments where each segment contains data for a given day of the week. Any query issued to the datasource for more than one day of data will hit more than one segment. These segments will likely be distributed across multiple processes, and hence, the query will likely hit multiple processes."),(0,s.kt)("p",null,"To determine which processes to forward queries to, the Broker process first builds a view of the world from information in Zookeeper. Zookeeper maintains information about ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/design/historical"},"Historical")," and streaming ingestion ",(0,s.kt)("a",{parentName:"p",href:"/docs/latest/design/peons"},"Peon")," processes and the segments they are serving. For every datasource in Zookeeper, the Broker process builds a timeline of segments and the processes that serve them. When queries are received for a specific datasource and interval, the Broker process performs a lookup into the timeline associated with the query datasource for the query interval and retrieves the processes that contain data for the query. The Broker process then forwards down the query to the selected processes."),(0,s.kt)("h3",{id:"caching"},"Caching"),(0,s.kt)("p",null,"Broker processes employ a cache with an LRU cache invalidation strategy. The Broker cache stores per-segment results. The cache can be local to each Broker process or shared across multiple processes using an external distributed cache such as ",(0,s.kt)("a",{parentName:"p",href:"http://memcached.org/"},"memcached"),". Each time a broker process receives a query, it first maps the query to a set of segments. A subset of these segment results may already exist in the cache and the results can be directly pulled from the cache. For any segment results that do not exist in the cache, the broker process will forward the query to the\nHistorical processes. Once the Historical processes return their results, the Broker will store those results in the cache. Real-time segments are never cached and hence requests for real-time data will always be forwarded to real-time processes. Real-time data is perpetually changing and caching the results would be unreliable."))}f.isMDXComponent=!0}}]);